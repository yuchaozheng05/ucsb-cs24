VoxHop writing task.

1.	Representation of the world map in memory
    a)	The map is represented as a 3D array of integers, where each integer represents a voxel. 
        For each voxel, it can either be full (1) or empty (0). The dimensions of the array are 
        defined by the width, depth, and height of the map. 

2.	Algorithm for performing route queries.
    a)	The algorithm that we used to perform route queries is a modified breadth-first search (BFS). 
        It explores all possible routes level by level, which ensures that the first valid route is 
        also the shortest in terms of the number of moves. 
    b)	Here is a brief overview of the steps: 
        i.	First, a queue is initialized with the starting voxel and mark it as visited.
        ii.	Next, for each voxel, explore its neighbors (Direction North, South, East, and West), and 
            for each neighbor, check if it can be a valid move. If the move is valid, check if the voxel 
            needs to fall or jump, and adjust the coordinates accordingly. 
        iii. Third, if it arrives at the destination, the route will be constructed via backtracking from 
            destination to the source using a parent map. 
        iv.	Lastly, the route will be represented as a line of moves or “No route is found”. 

3.	Data structures used:
    a)	Vector (3D array): Used to store the map.
    b)	Queue: Used in the BFS algorithm in order to manage the exploration of voxels. 
    c)	Map: Store the parent of each voxel used for backtracking. 
    d)	Set: Used to keep in track of visited voxel to prevent re-exploration. 

    We chose these data structures for their efficiency in terms of access and insertion times. 

4.	Runtime analysis:
    a)	Map reading: Time complexity of O (width * depth * height)
    b)	BFS: Worst case O (width * depth * height). Each voxel exploration involves checking its neighbors and 
        possibly adjusting coordinates for jump/falls, which is a constant time operation. 
    c)	Total runtime: The overall runtime of the program is dominated by the BFS algorithm, making it O (W * D * H). 
        Since the map reading and BFS have the same time complexity, the total runtime remains O (W * D * H).